import unittest
import config
import numpy as np
import RoboterArm
import Geometrie

class TestGeometrie(unittest.TestCase):
    
    def test_reflect_on_hypotenuse(self):
        x, y = Geometrie.reflect_on_hypotenuse(-2, 2, 0, 0, 0, 3)
        self.assertEqual(x, 2)
        self.assertEqual(y, 2)

        x, y = Geometrie.reflect_on_hypotenuse(2, 2, 0, 0, 0, 3)
        self.assertEqual(x, -2)
        self.assertEqual(y, 2)

        x, y = Geometrie.reflect_on_hypotenuse(0, 2, 0, 0, 0, 3)
        self.assertEqual(x, 0)
        self.assertEqual(y, 2)

        x, y = Geometrie.reflect_on_hypotenuse(0, 2, 0, 3, 0, 0)
        self.assertEqual(x, 0)
        self.assertEqual(y, 2)

        x, y = Geometrie.reflect_on_hypotenuse(0, 2, 0, 0, 2, 2)
        self.assertEqual(x, 2)
        self.assertEqual(y, 0)
        return
        
    def test_which_side_small_angle(self):
        arm = RoboterArm.RoboticArm(config.coxa_length,config.femur_length,config.tibia_length)
        arm.update_joints(np.pi/4, np.pi/2, np.pi*3/2)
        self.assertEqual(Geometrie.which_side_small_angle(arm.theta_coxa), 0)
        self.assertEqual(Geometrie.which_side_small_angle(arm.theta_femur), 0)
        self.assertEqual(Geometrie.which_side_small_angle(arm.theta_tibia), 1)

    '''
    def test_which_side_obstacle_to_coxa(self):
        arm = RoboterArm.RoboticArm(config.coxa_length,config.femur_length,config.tibia_length)
        arm.update_joints(0, np.pi/2, np.pi/2)
        self.assertEqual(Geometrie.which_side_obstacle_to_coxa(arm, config.center), 0)

        arm.update_joints(np.pi, np.pi/2, np.pi/2)
        self.assertEqual(Geometrie.which_side_obstacle_to_coxa(arm, config.center), 1)
        return
    '''

    def test_distance_segment_point(self):
        result = Geometrie.distance_segment_point(3, 3, 0, 0, 0, 5)
        self.assertEqual(result, 3)

        result = Geometrie.distance_segment_point(-3, 3, 0, 0, 0, 5)
        self.assertEqual(result, 3)
    
    def test_side_point_to_line(self):
        result = Geometrie.side_point_to_line(1, 0, 0, 0, 1, 1)
        self.assertEqual(result, 1)

        result = Geometrie.side_point_to_line(0, 1, 0, 0, 1, 1)
        self.assertEqual(result, 0)

        result = Geometrie.side_point_to_line(0, 1, 1, 1, 0, 0)
        self.assertEqual(result, 1)
        return
    
    def test_boolean_switch_elbow(self):
        arm = RoboterArm.RoboticArm(config.coxa_length,config.femur_length,config.tibia_length)
        arm.update_joints(np.pi/4, np.pi/4, np.pi/4)
        config.center = (-1, 5)
        bool_result_coxa, bool_result_tibia = Geometrie.booleans_switch_elbows(arm, config.center)

        # Should both be on correct side
        self.assertEqual(bool_result_coxa, 1)
        self.assertEqual(bool_result_tibia, 1)

        arm.update_joints(np.pi/4, np.pi/4, np.pi*3/2)
        config.center = (-1, 5)
        bool_result_coxa, bool_result_tibia = Geometrie.booleans_switch_elbows(arm, config.center)

        # Coxa should still be correct, tibia on the other side
        self.assertEqual(bool_result_coxa, 1)
        self.assertEqual(bool_result_tibia, 0)

        arm.update_joints(np.pi/4*5, np.pi/4, 0)
        config.center = (-1, 5)
        bool_result_coxa, bool_result_tibia = Geometrie.booleans_switch_elbows(arm, config.center)

        # Should both be on wrong side
        self.assertEqual(bool_result_coxa, 0)
        self.assertEqual(bool_result_tibia, 0)
        return

if __name__ == "__main__":
    unittest.main()
    